操作次数为 $2$，要么是先操作前 $2n$ 个数，再操作后 $2n$ 个数，要么就两个操作交换。而这样能完成排序的充分必要条件是前 $n$ 小的数在前 $2n$ 个数中或者前 $n$ 大的数在后 $2n$ 个数中。

对于第一种情况，首先从前 $2n$ 个位置中选出 $n$ 个位置放前 $n$ 小的数，然后这 $n$ 个位置任意排序，其它 $2n$ 个位置任意排序即可。第二种情况也是如此，故方案数为

$$
2\binom{2n}n(2n)!n!.
$$

接着考虑两种情况的重复部分。枚举中间 $n$ 个位置中区间 $[2n+1,3n]$ 的数的个数 $i$，此时需要从这 $n$ 个位置中选出这 $i$ 个位置（$\dbinom ni$），再从后 $n$ 个位置中选出剩下 $n-i$ 个位置（$\dbinom n{n-i}$），最后再从前 $2n$ 个位置剩下的位置（共 $2n-i$ 个）中选出 $n$ 个位置（$\dbinom{2n-i}n$）即可。

```cpp
count2=2*C(n<<1,n)*fac[n]%mod*fac[n<<1]%mod;
long long tmp=fac[n]*fac[n]%mod*fac[n]%mod;
// 2n+1 ~ 3n 中有 i 个在 [n+1, 2n] 上
for(int i=0;i<=n;i++)
    count2-=tmp*C(n,i)%mod*C(n,n-i)%mod*C(2*n-i,n)%mod;
```