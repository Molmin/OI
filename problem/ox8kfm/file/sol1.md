首先将所有的询问存放在 **操作序列 $Q$** 中。$Q$ 中的每个元素都记录下矩形坐标、$k$ 的值以及询问编号。特别地，我们把初始化矩阵的 $n\times n$ 个数也视为操作产生，放入操作序列 $Q$ 中。

（注意到矩阵中共 $n^2$ 个数，共有 $q$ 次询问，所以操作序列 $Q$ 的容量应达到 $n^2+q\leq 3.1\times 10^5$。）

我们定义如下函数来完成操作区间 $[Ql,\ Qr]$ 中的操作：

```cpp
void binarySearch(int Ql,int Qr,int l,int r);
```

这意味着我们已知操作区间 $[Ql,\ Qr]$ 中的操作答案都在 $[l,\ r]$ 中，那么我们就可以写出入口函数（其中 `Qcnt` 表示操作总数）：

```cpp
binarySearch(1,Qcnt,0,1e9);
```

接下来考虑如何实现 `binarySearch` 函数。

先对答案进行二分，即令 $\text{mid}=\left\lfloor\dfrac{l+r}2\right\rfloor$。

接着我们需要在操作区间 $[Ql,\ Qr]$ 中对操作进行分类。分别求出它们的答案是否 $\leq\text{mid}$，然后只需交换操作之间的位置，进行下一层整体二分即可。

如何判断答案是否 $\leq\text{mid}$？考虑维护一个二维矩阵，每个数的值为 $0$ 或 $1$ 表示是否 $\leq\text{mid}$。遇到询问时，就求出矩阵内的数和，判断其是否 $< k$ 即可；而遇到修改时，则应修改对应位置的值。在遍历结束后，再将加的 $1$ 减掉即可。

最后，当二分的范围变为单个数时，就确定了答案，进行答案赋值。